---
marp: false
theme: gaia
---

# Stateful Smart Contracts On Cardano

## Part 1. Securing The Distributed State

### Minting Unique Tokens With A Shared `PolicyId`

Lorenzo Fanton

887857@stud.unive.it

---

## Problem

Our needs, at the lowest level:

1. We want to distribute a smart contract's state over mutiple UTxOs, _and_...

2. ... We must ensure that it cannot be compromised by an attacker.

Otherwise, it would be pointless to use whatever abstractions we might come up with.

---

## Problem

An informal statement of the problem might be the following.

> A smart contract's state, distributed over multiple of UTxOs, should be modified only by transactions validated by the smart contract itself.

---

## Problem

There are good news and bad news.

* **Good news**: Smart contracts (on-chain) can enforce the recipient(s) of the UTxOs being created, but...

* **Bad news**: ... They have **zero knowledge** about the sender of the UTxOs being spent.

Why is that a problem?

---

## Example: Good State

![height:400px](./img/auth-good-state.png)

---

## Example: Attacker Setup

![height:400px](./img/auth-attacker.png)

---

## Example: (Very) Bad State

![height:400px](./img/auth-bad-state.png)

---

## Problem

Compromised state could be the source of other, more serious issues. 

What could be worse than WW3? Well, for example:

> _You_ could be losing money!!

While total thermonuclear annihilation might be somewhat tolerable and even fun, losing money is not and we must avoid that at all costs.

---

## Solution

We need a way to authenticate the UTxOs that get consumed/produced by the transactions validated by our smart contract.

**Idea**: What if we had a set of unique "tokens", known by the contract, that could be propagated alongside each UTxO?

Congrats. We have just discovered NFTs.

---

## Native Tokens

Native tokens, also called _assets_ on Cardano, are defined as:

* $\text{AssetId} := \text{PolicyId} \times \text{AssetName}$
* $\text{PolicyId} := (\mathbb{F}_{256})^{28}$ (hash of the minting validator script)
* $\text{AssetName} := (\mathbb{F}_{256})^{32}$ (arbitrary string)

Where $\mathbb{F}_q := \lbrace 0,\dots,q-1 \rbrace$.

---

## Native Tokens

On Cardano, every asset is a Native Token. Even ADA can be considered as such (with an empty policy id, since there is no mint script for ADA).

In fact, UTxOs can carry Native Tokens, not just ADA.

---

## Fungible, Non Fungible

Two tokens are said to be _fungible_ if they have the same asset id. 

Example: if I have an amount of `("0x1", "lore")`, then I have 2 tokens that fungible (one with each other).

If I have 1 of `("0x1", "hammad")` and 1 of `("0x1", "lore")`, the two are not fungible.

If I have 1 of `("0x1", "hammad")` and 1 of `("0x2", "hammad")`, the two are not fungible.

--- 

## Spending Validators

We call $V$ the type of a Spending Validator:

$$
V := (\text{Datum} \times \text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

---

## Minting Validators

We call $M$ the type of a Minting Validator:

$$
M := (\text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

**NB**: Minting Validators do not take a $\text{Datum}$ as inputs, because they do not spend UTxOs.

---

## Minting The NFTs

Let $\text{OutputReference}$ represent an on-chain reference to an UTxO.

We declare the following functions that produce smart contracts:

* $f_{start,mint} : \text{OutputReference} \rightarrow M$

* $f_{add,mint} : M \rightarrow M$

* $f_{add,validate} : (M \times M) \rightarrow V$

---

## Minting The NFTs

$f_{start,mint}$ takes an $\text{OutputReference}$ `o` and returns a Minting Validator that produces a single token with $\text{AssetName}$ `"Auth"`.

Such script is a **one-time** minting validator, because it ensures that `o` is consumed in the transaction (which can happen only once).

---

## Code: $f_{start,mint} : \text{OutputReference} \rightarrow M$

![height:400px](./img/auth-newm-code.png)

---

## Code: $f_{add, validate} : (M \times M) \rightarrow V$

![height:400px](./img/auth-addv-code.png)

---

## Code: $f_{add, mint} : M \rightarrow M$

![height:400px](./img/auth-addm-code.png)

---

## Minting The NFTs

In particular, let $o : \text{OutputReference}$.

We build the following three contracts that will take part in the generation of our NFTs:

* $(s : M) = f_{start,mint}(o)$

* $(a_M : M) = f_{add,mint}(s)$

* $(a_V : V) = f_{add,validate}(s, a_M)$

---

## Dependencies

![height:300px](./img/auth-dependencies.png)

**NB**: "$\rightarrow$" means "depends on".

---

## Example: Full Example

![width:1000px](./img/auth-full.png)

**NB** Cyan UTxOs contain the minted NFTs that we will use to authenticate our smart contract's state.

---

## Example: Start The Minting Process

![height:400px](./img/auth-start.png)

---

## Example: Minting The 1st NFT

![height:400px](./img/auth-add1.png)

---

## Example: Minting The 2nd NFT


![height:400px](./img/auth-add2.png)
