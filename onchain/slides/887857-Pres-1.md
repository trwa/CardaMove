---
marp: false
theme: gaia
---

# Stateful Smart Contracts On Cardano

## Part 1. Securing The Distributed State.

Lorenzo Fanton

887857@stud.unive.it

---

## Problem

At the lowest level, we need to:

1. Distribute a smart contract's state over _mutiple_ UTxOs, _and_...

2. ... Ensure that it cannot be compromised by an attacker.

Otherwise, it would be pointless to use whatever abstractions we might come up with.

---

## Problem

An informal statement of the problem might be the following.

> A smart contract's state, distributed over multiple of UTxOs, should be modified only by transactions validated by the smart contract itself.

---

## Problem

There are good news and bad news.

* **Good news**: Smart contracts (on-chain) can enforce the recipient(s) of the UTxOs being created, but...

* **Bad news**: ... They have **zero knowledge** about the sender of the UTxOs being spent.

**Why is that a problem?**

---

## Example: Good State

![height:300px](./img/auth-good-state.png)

In a normal setup, a stateful smart contract would ensure that the state is propagated to itself.

---

## Example: Attacker Setup

![height:300px](./img/auth-attacker.png)

However, an attacker might craft a malicious piece of state and "pay" it to the smart contract. Nothing would prevent them to do so.

---

## Example: (Very) Bad State

![height:300px](./img/auth-bad-state.png)

Now the smart contract would mindlessly use that piece of state to validate whatever transaction. **The contract's state is now compromised.**

---

## Problem

Compromised state could be the source of other, more serious issues. 

What could be worse than WW3? Well, for example:

> _You_ could be losing money!!

While total thermonuclear annihilation might be somewhat tolerable and even fun, losing money is not and we must avoid that at all costs.

---

## Solution

How can we authenticate the UTxOs that get consumed/produced by the transactions validated by our smart contract?

For example, by using a set of unique "tokens" attached to each UTxO, such that:

* They are easily recognizable by the smart contract
* They can be extended without modifying the contract's source code

Enter NFTs.

---

## Native Tokens And NFTs

Native tokens, also called _assets_ on Cardano, are (loosely) objects that represent value. Technically, ADA is a (very special) type of native token.

Native tokens are idenfied by their "asset id", of type $\text{AssetId} = \text{PolicyId} \times \text{AssetName}$:

* $\text{PolicyId} = (\mathbb{F}_{256})^{28}$ hash of the minting script;

* $\text{AssetName} = (\mathbb{F}_{256})^{32}$ arbitrary 32-byte string.

Where $\mathbb{F}_q := \lbrace 0,\dots,q-1 \rbrace$.

---

## Fungible, Not Fungible

Two tokens are said to be _fungible_ if they have the same asset id. 

Example: 

* If I have 2 of `("0x1", "lorenzo")`, then I have 2 tokens that **are** fungible.

* If I have 1 of `("0x1", "hammad")` and 1 of `("0x1", "lorenzo")`, the two tokens **are not** fungible.

* If I have 1 of `("0x1", "hammad")` and 1 of `("0x2", "hammad")`, the two tokens **are not** fungible.

---

## Minting Native Tokens

Minting is the process of creating new tokens. A minting validator is just a smart contract with the following signature $M$:

$$
M = (\text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

Minting validators do not take a $\text{Datum}$ as argument, because they do not spend UTxOs.

--- 

## Spending UTxOs

In contrast, spending validators are smart contracts with the following signature $V$:

$$
V = (\text{Datum} \times \text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

The $\text{Redeemer}$ would be actually not necessary (there exists a second signature without it) but for all our purposes we will use redeemers.

---

## Minting The NFTs

Let $\text{OutputReference}$ represent an on-chain reference to an UTxO.

We declare the following functions that produce smart contracts:

* $f_{start,mint} : \text{OutputReference} \rightarrow M$

* $f_{add,mint} : M \rightarrow M$

* $f_{add,validate} : (M \times M) \rightarrow V$

---

## Key Properties

* $o_1 \neq o_2 \iff f_{start,mint}(o_1) \neq f_{start,mint}(o_2)$

* $s_1 \neq s_2 \iff f_{add,mint}(s_1) \neq f_{add,mint}(s_2)$

* $(s_1, a_1) \neq (s_1, a_2) \iff f_{add,validate}(s_1, a_1) \neq f_{add,validate}(s_2, a_2)$

---

## Minting The NFTs

$f_{start,mint}$ takes an $\text{OutputReference}$ `o` and returns a Minting Validator that produces a single token with $\text{AssetName}$ `"Auth"`.

Such script is a **one-time** minting validator, because it ensures that `o` is consumed in the transaction (which can happen only once).

---

## Code: $f_{start,mint} : \text{OutputReference} \rightarrow M$

![height:400px](./img/auth-newm-code.png)

---

## Code: $f_{add, validate} : (M \times M) \rightarrow V$

![height:400px](./img/auth-addv-code.png)

---

## Code: $f_{add, mint} : M \rightarrow M$

![height:400px](./img/auth-addm-code.png)

---

## Minting The NFTs

In particular, let $o : \text{OutputReference}$.

We build the following three contracts that will take part in the generation of our NFTs:

* $(s : M) = f_{start,mint}(o)$

* $(a_M : M) = f_{add,mint}(s)$

* $(a_V : V) = f_{add,validate}(s, a_M)$

---

## Dependencies

![height:300px](./img/auth-dependencies.png)

**NB**: "$\rightarrow$" means "depends on".

---

## Example: Full Example

![width:1000px](./img/auth-full.png)

**NB** Cyan UTxOs contain the minted NFTs that we will use to authenticate our smart contract's state.

---

## Example: Start The Minting Process

![height:400px](./img/auth-start.png)

---

## Example: Minting The 1st NFT

![height:400px](./img/auth-add1.png)

---

## Example: Minting The 2nd NFT


![height:400px](./img/auth-add2.png)
