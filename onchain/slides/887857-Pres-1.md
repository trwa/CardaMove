---
marp: false
theme: gaia
---

# Stateful Smart Contracts On Cardano

## Part 1. Securing The Distributed State.

Lorenzo Fanton

887857@stud.unive.it

---

## Problem

At the lowest level, we need to:

1. Distribute a smart contract's state over _mutiple_ UTxOs, _and_...

2. ... Ensure that it cannot be compromised by an attacker.

Otherwise, it would be pointless to use whatever abstractions we might come up with.

---

## Problem

An informal statement of the problem might be the following.

> A smart contract's state, distributed over multiple of UTxOs, should be modified only by transactions validated by the smart contract itself.

---

## Problem

There are good news and bad news.

* **Good news**: Smart contracts (on-chain) can enforce the recipient(s) of the UTxOs being created, but...

* **Bad news**: ... They have **zero knowledge** about the sender of the UTxOs being spent.

**Why is that a problem?**

---

## Example: Good State

![height:300px](./img/auth-good-state.png)

In a normal setup, a stateful smart contract would ensure that the state is propagated to itself.

---

## Example: Attacker Setup

![height:300px](./img/auth-attacker.png)

However, an attacker might craft a malicious piece of state and "pay" it to the smart contract. Nothing would prevent them to do so.

---

## Example: (Very) Bad State

![height:300px](./img/auth-bad-state.png)

Now the smart contract would mindlessly use that piece of state to validate whatever transaction. **The contract's state is now compromised.**

---

## Problem

Compromised state could be the source of other, more serious issues. 

What could be worse than WW3? Well, for example:

> _You_ could be losing money!!

While total thermonuclear annihilation might be somewhat tolerable and even fun, losing money is not and we must avoid that at all costs.

---

## Solution

How can we authenticate the UTxOs that get consumed/produced by the transactions validated by our smart contract?

For example, by using a set of unique "tokens" attached to each UTxO, such that:

* They are easily recognizable by the smart contract
* They can be extended without modifying the contract's source code

Enter NFTs.

---

## Native Tokens And NFTs

Native tokens, also called _assets_ on Cardano, are (loosely) objects that represent value. Technically, ADA is a (very special) type of native token.

Native tokens are idenfied by their "asset id", of type $\text{AssetId} = \text{PolicyId} \times \text{AssetName}$:

* $\text{PolicyId} = (\mathbb{F}_{256})^{28}$ hash of the minting script;

* $\text{AssetName} = (\mathbb{F}_{256})^{32}$ arbitrary 32-byte string.

Where $\mathbb{F}_q := \lbrace 0,\dots,q-1 \rbrace$.

---

## Fungible, Not Fungible

Two tokens are said to be _fungible_ if they have the same asset id. 

Example: 

* If I have 2 of `("0x1", "lorenzo")`, then I have 2 tokens that **are** fungible.

* If I have 1 of `("0x1", "hammad")` and 1 of `("0x1", "lorenzo")`, the two tokens **are not** fungible.

* If I have 1 of `("0x1", "hammad")` and 1 of `("0x2", "hammad")`, the two tokens **are not** fungible.

---

## Minting Native Tokens

Minting is the process of creating new tokens. A minting validator is just a smart contract with the following signature $M$:

$$
M = (\text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

Minting validators do not take a $\text{Datum}$ as argument, because they do not spend UTxOs.

--- 

## Spending UTxOs

By contrast, spending validators are smart contracts with the following signature $V$:

$$
V = (\text{Datum} \times \text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

---

## Properties Of Tokens

We said earlier that we want to utilize unique tokens, to guarantee that each piece of the smart contract's state is indeed valid. Firstly, we have to discuss two desired properties of such tokens.

In particular, let $T$ the minting process detailed in the following slides.

1. $\forall t_1,t_2$ tokens from $T$ : $t_1 \neq t_2$ using the asset id to test for equality.

2. $\forall t_1,t_2$ tokens from $T$ : $\exists \sim$ such that $t_1 \sim t_2$. We will show that one suitable $\sim$ is precisely "$t_1$ and $t_2$ have the same policy id".

---

## Properties Of Tokens

In particular, if we manage to mint NFTs we get (1) basically for free.

The (2) is tougher. Usually on Cardano NFTs are produced from a single script either setting timers for the validity of the contract, or parametrizing the contract with a UTxO reference and making sure to spend it in the transaction (in order to achieve a one-time mint validator).

---

## Properties Of Tokens

However, this means that in order to produce new NFTs you would need a different contract (using different UTxO references changes the actual compiled code). In the context of native tokens, different minting validators yield different policy ids.

What we are going to achieve is a "minting process" to have multiple NFTs from the same policy id.

---

## Multiple NFTs From The Same PolicyId

Let $\text{OutputReference}$ represent an on-chain reference to an UTxO.

We declare the following functions:

* $f_{start,mint} : \text{OutputReference} \rightarrow M$

* $f_{add,mint} : M \rightarrow M$

* $f_{add,validate} : (M \times M) \rightarrow V$

Where $M$ is "minting validator" and $V$ is "spending validator". **NB**: With abuse of notation, we use the actual validator instead of its hash (when used as argument). Obviously, in real code the hash is used.

---

## Multiple NFTs From The Same PolicyId

Some key properties:

* $o_1 \neq o_2 \iff f_{start,mint}(o_1) \neq f_{start,mint}(o_2)$

* $s_1 \neq s_2 \iff f_{add,mint}(s_1) \neq f_{add,mint}(s_2)$

* $(s_1, a_1) \neq (s_1, a_2) \iff f_{add,validate}(s_1, a_1) \neq f_{add,validate}(s_2, a_2)$

---

## Code: $f_{start,mint} : \text{OutputReference} \rightarrow M$

![height:400px](./img/auth-newm-code.png)

---

## Code: $f_{add, validate} : (M \times M) \rightarrow V$

![height:400px](./img/auth-addv-code.png)

---

## Code: $f_{add, mint} : M \rightarrow M$

![height:400px](./img/auth-addm-code.png)

---

## Multiple NFTs From The Same PolicyId

In particular, let $o : \text{OutputReference}$.

We build the following three contracts that will take part in the generation of our NFTs:

* $(s : M) = f_{start,mint}(o)$ is the "start script".

* $(a_M : M) = f_{add,mint}(s)$ is the script for creating a new NFT.

* $(a_V : V) = f_{add,validate}(s, a_M)$ is the script for co-validating most of the minting.

---

## Dependencies

![height:300px](./img/auth-dependencies.png)

**NB**: "$\rightarrow$" means "depends on".

---

## Multiple NFTs From The Same PolicyId

TODO: simple description of the schema.

---

## Example: Full Example

![width:1000px](./img/auth-full.png)

**NB**: UTxOs coloured cyan contain the minted NFTs that we will use to authenticate our smart contract's state.

---

## Example: Start The Minting Process

![height:400px](./img/auth-start.png)

---

## Example: Minting The 1st NFT

![height:400px](./img/auth-add1.png)

---

## Example: Minting The 2nd NFT

![height:400px](./img/auth-add2.png)

---

## Final Notes

Finally, we can use them. 

A smart contract would just need to know the hash of $a_M$ (the policy id of the NFTs). The uniqueness of them is guaranteed by the validators. Lastly, a valid "piece of state" would be one associated to the NFT. The smart contract would have to make sure to pay the NFT back to itself.

---

## Critical Points

* The "Auth" NFT must be paid to $a_V$ in the same transaction it is minted

* The data NFTs must be paid to the smart contract, giving the correct initial datum.

## Easy Solutions

* Make the start transaction use a minting validator and a spend validator. The spend validator knows about $a_V$ and pays to it.

* Make $a_V$ know about the actual smart contract, and make it pay to it.
