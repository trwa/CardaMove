---
marp: false
theme: gaia
---

# Stateful Smart Contracts On Cardano

## Part 1. Securing A Distributed State

### Minting Unique Tokens With A Shared `PolicyId`

Lorenzo Fanton

887857@stud.unive.it

---

## Problem

Our needs, at the lowest level:

1. We want to distribute a smart contract's state over mutiple UTxOs, _and_...

2. ... We must ensure that it cannot be compromised by an attacker.

Otherwise, it would be pointless to use whatever abstractions we might come up with.

---

## Problem

An informal statement of the problem might be the following.

> A smart contract's state, distributed over multiple of UTxOs, should be modified only by transactions validated by the smart contract itself.

---

## Problem

There are good news and bad news.

* **Good news**: Smart contracts (on-chain) can enforce the recipient(s) of the UTxOs being created, but...

* **Bad news**: ... They have **zero knowledge** about the sender of the UTxOs being spent.

Why is that a problem?

---

## Example: Good State

![height:400px](./img/auth-good-state.png)

---

## Example: Attacker Setup

![height:400px](./img/auth-attacker.png)

---

## Example: (Very) Bad State

![height:400px](./img/auth-bad-state.png)

---

## Problem

Compromised state could be the source of other, more serious issues. 

What could be worse than WW3? Well, for example:

> _You_ could be losing money!!

While total thermonuclear annihilation might be somewhat tolerable and even fun, losing money is not and we must avoid that at all costs.

---

## Native Tokens

Native tokens, also called _assets_, are defined as:

* $\text{AssetId} := \text{PolicyId} \times \text{AssetName}$
* $\text{PolicyId} := (\mathbb{F}_{256})^{28}$ (hash of the minting validator script)
* $\text{AssetName} := (\mathbb{F}_{256})^{32}$ (arbitrary string)

Where $\mathbb{F}_q := \lbrace 0,\dots,q-1 \rbrace$.

---

## Spending Validators

We call $V$ the type of a Spending Validator:

$$
V := (\text{Datum} \times \text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

---

## Minting Validators

We call $M$ the type of a Minting Validator:

$$
M := (\text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

**NB**: Minting Validators do not take a $\text{Datum}$ as inputs, because they do not spend UTxOs.

---

## Minting The NFTs

Let $\text{OutputReference}$ represent an on-chain reference to an UTxO.

We declare the following functions that produce smart contracts:

* $f_{start,mint} : \text{OutputReference} \rightarrow M$

* $f_{add,mint} : M \rightarrow M$

* $f_{add,validate} : (M \times M) \rightarrow V$

---

## Minting The NFTs

$newm$ takes an $\text{OutputReference}$ `utxo` and returns a Minting Validator that produces a single token with $\text{AssetName}$ `"Auth"`.

Such script is a **one-time** minting validator, because it ensures that `utxo` is consumed in the transaction (which can happen only once).

---

## Code: $f_{start,mint} : \text{OutputReference} \rightarrow M$

![height:400px](./img/auth-newm-code.png)

---

## Code: $f_{add, validate} : (M \times M) \rightarrow V$

![height:400px](./img/auth-addv-code.png)

---

## Code: $f_{add, mint} : M \rightarrow M$

![height:400px](./img/auth-addm-code.png)

---

## Minting The NFTs

In particular, let $o : \text{OutputReference}$.

We build the following three contracts that will take part in the generation of our NFTs:

* $(s : M) = f_{start,mint}(o)$

* $(a_M : M) = f_{add,mint}(s)$

* $(a_V : V) = f_{add,validate}(s, a_M)$

---

## Dependencies

![height:300px](./img/auth-dependencies.png)

**NB**: "$\rightarrow$" means "depends on".

---

## Example: Full Example

![width:1000px](./img/auth-full.png)

**NB** Cyan UTxOs contain the minted NFTs that we will use to authenticate our smart contract's state.

---

## Example: Start The Minting Process

![height:400px](./img/auth-start.png)

---

## Example: Minting The 1st NFT

![height:400px](./img/auth-add1.png)

---

## Example: Minting The 2nd NFT


![height:400px](./img/auth-add2.png)
