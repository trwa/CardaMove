---
marp: true
theme: gaia
---

# Address-Bound NFTs on Cardano: One Token Per Address with a Shared PolicyId

Implementation of the paper "Dominant-set clustering: A review" (S. Rota Bulò, M. Pelillo).

Discrete-time replicator dynamics with peel-off strategy.

Experiments of pure functional programming on the GPU.

Lorenzo Fanton - 887857@stud.unive.it

---

## Clustering With Graph Similarities

$M = (\mathcal{R} \times \mathcal{C}) \rightarrow \mathbb{B}$

$V = (\mathcal{D} \times \mathcal{R} \times \mathcal{C}) \rightarrow \mathbb{B}$

$newm : (\Sigma^{32} \times \mathcal{O}) \rightarrow M$

$addv : (M \times \Sigma^{32} \times M) \rightarrow V$

$addm : (M \times \Sigma^{32}) \rightarrow M$

---

## Average Weighted In-Degree

Let $G=(V, E)$. Let $C\subseteq V$. Let $A$ similarity matrix. Then $\forall i\in V$ the _average weighted in degree_ wrt. $C$ is defined as:

$$
\text{awindeg}_C(i)=\dfrac{1}{|C|}\sum_{j\in C}A_{ij}
$$

---

## Relative Similarity

Measure of how much $j$ is similar to $i\in C$ relative to the average similarity of $i$ to the rest of $C$.

$$
\phi_C(i, j)=A_{ij}-\text{awindeg}_C(j)
$$

---

## Weight

Weight of a vertex with respect to the cluster:

$$
W_C(i)=\begin{cases} 
1 & |C|=1 \\
\text{let}~C_{-i}=C\setminus\lbrace i\rbrace~\text{in}~\sum_{j\in C_{-i}}\phi_{C_{-i}} (i, j)~W_{C_{-i}}(i)& \text{otherwise}
\end{cases}
$$

Weight of the cluster:

$$
W(C)=\sum_{i\in C}W_C(i)
$$

---

## Weighted Characteristic Vector

$\mathbf{x}^C$ such that:

$$
x_i^C=\begin{cases} 
\dfrac{W_C(i)}{W(C)} & i \in C \\
0 & \text{otherwise}
\end{cases}
$$

---

## Definition Of Dominant Set

Let $C\subseteq V$ (such that $\forall T \subseteq C.~W(T)>0$). Then $C$ is a _dominant set_ if:

1. $\forall i \in C. ~W_C(i) > 0$ (internal homogeneity criterion)

2. $\forall j \notin C.~W_{C\cup \lbrace j \rbrace}(j)<0$ (maximality criterion)

---

## Finding Dominant Sets

If $A$ is a _symmetric_ similarity matrix, then dominant sets are the local solutions to the _Standard Quadratic Program_ (`StQP`):

$$
\begin{array}{cc}
\text{maximize}   & f(\mathbf{x})=\mathbf{x}^\top A \mathbf{x} \\
\text{subject to} & \mathbf{x} \in \Delta^n
\end{array}
$$

Since local solutions correspond to $\mathbf{x}^C$.

---

## Futhark Programming Language

* Purely functional **array** programming language

* Hindley-Milner type sistem with:
    - Uniqueness types
    - Size-dependent types

Link: https://futhark-lang.org/

---

## Discrete-Time Replicator Dynamics

Step:

$$
x_i(t+1)=x_i(t)\dfrac{(A\mathbf{x}(t))_i}{\mathbf{x}(t)^\top A \mathbf{x}(t)}
$$

Code:

```
local def step [n] (A: [n][n]f32) (x: [n]f32): [n]f32 =
    let A_x = map (dot x) A
    let xT_A_x = dot x A_x
    in mult x (frac A_x xT_A_x)
```

---

## Discrete-Time Replicator Dynamics

Solve for one cluster, masking only the entries that have **not** been extracted. Code:

```
local def solve [n] (A: [n][n]f32) (epsilon: f32) (mask: [n]bool): [n]f32 =
    let ntrue = sum (map f32.bool mask)
    let pinit = 1.0 / ntrue
    let x0 = map (\mi -> if mi then pinit else 0) mask
    let d0 = -1.0
    let (_, xn) = loop (dk, xk) = (d0, x0) while dk < 0 || epsilon < dk do
        let x1 = step A xk
        let d1 = dist x1 xk
        in (d1, x1)
    in xn
```

---

## Cluster Extraction

Support of $\mathbf{x} \in \Delta^n$:

$$
\sigma(\mathbf{x}) = \lbrace i | x_i > 0 \rbrace
$$

If $\mathbf{x}$ is a solution of `StQP`, then the support identifies the cluster. (Theorem 1, Theorem 3)

...difficult to get desired results (insufficient numerical precision?)

---

## Cluster Extraction

We can check for the **support condition** (Equation 5):

$$
\begin{cases} 
(A \mathbf{x})_i = \mathbf{x}^\top A \mathbf{x} & i \in \sigma(\mathbf{x}) \\
(A \mathbf{x})_i \leq \mathbf{x}^\top A \mathbf{x} & i \notin \sigma(\mathbf{x})
\end{cases}
$$

Code:

```
local def support [n] (A: [n][n]f32) (theta: f32) (x: [n]f32): [n]bool =
    let A_x = map (dot x) A
    let xT_A_x = dot x A_x
    in map (\xi -> f32.abs (xi - xT_A_x) <= theta) A_x
```

---

## Peel-Off Strategy

Extract one cluster, then zero-out its corresponding pixels. Code:

```
local def peel_off [n] (epsilon: f32) (theta: f32) (k: u8) (A: [n][n]f32): [n]u8 =
    let g0 = 1.0
    let c0 = replicate n 0
    let A0 = A
    let (_, ck, _) = loop (gl, cl, Al) = (g0, c0, A0) for _l < i16.u8 k do
        let mask: [n]bool = map (== 0) cl
        let supp: [n]bool = solve Al epsilon mask |> support Al theta
        let color si ci = if si then u8.f32 (gl * 255.0) else ci
        let g1 = gl - (1.0 / f32.u8 k)
        let c1 = map2 color supp cl
        let A1 = supp |> remove Al
        in (g1, c1, A1)
    in ck
```

---

## Gaußian Kernel

$$
K_{\sigma}(\mathbf{x}, \mathbf{y})=\exp\left(-\dfrac{||\mathbf{x} - \mathbf{y}||_2^2}{2\sigma^2}\right)
$$

Code:

```
local def kernel [k] (sigma: f32) (x: [k]f32) (y: [k]f32): f32 =
    let d2 = (diff x y |> norm)**2
    let s2 = sigma**2
    in f32.exp (- d2 / (2.0 * s2))
```

---

## Pixel Preprocessing

Convert RGB to RGBL, where L is the perceived luminance. Channels are rescaled to $0.0-1.0$. Code:

```
local def prep (px: [3]u8): [4]f32 =
    let r = (f32.u8 px[0]) / 1.0
    let g = (f32.u8 px[1]) / 1.0
    let b = (f32.u8 px[2]) / 1.0
    let l = f32.sqrt (0.241 * (r ** 2) + 0.691 * (g ** 2) + 0.068 * (b ** 2))
    in [r, g, b, l]
```

---

## Affinity Matrix

Compute the symmetric affinity matrix using the Gaußian kernel. Code:

```
local def affinity [m][n] (sigma: f32) (px: [m][n][3]u8) : [m*n][m*n]f32 =
    let x = flatten px |> map prep
    in map (\xi -> map (\xj -> kernel sigma xi xj) x) x
```

Space complexity is $\Theta(m^2n^2)$.
Exact space required is $4m^2n^2$ bytes.

---

## Entry Point

Main $DS$ algorithm:

```
entry main [m][n] (px: [m][n][3]u8) (sigma: f32) (epsilon: f32) (theta: f32) (k: u8): [m][n]u8 = 
    let x = affinity sigma px |> peel_off epsilon theta k
    in unflatten x
```

Input: 
*   `px`: RGB pixel values, 2D image.
*   `sigma`: Kernel's $\sigma$.
*   `epsilon`: Stop iterating under this threshold difference.

---

## Entry Point

Input:

* `k`: Number of clusters to extract (one less than those shown).

Output:
*   Grayscale, single-channel 2D image.

Each level of gray indicates one cluster.

---

## Examples

$DS($![](../img/eiffel.png) $,\sigma=100, \epsilon=0.0001, \theta=0.3, k=2)\mapsto$ ![](../img/eiffelc.png)

$DS($![](../img/baseball.png) $,\sigma=100, \epsilon=0.001, \theta=0.4, k=3)\mapsto$ ![](../img/baseballc.png)

$DS($![](../img/rat.png) $,\sigma=100, \epsilon=0.001, \theta=0.1, k=3)\mapsto$ ![](../img/ratc.png)

$DS($![](../img/apples.jpg) $,\sigma=100, \epsilon=0.001, \theta=0.08, k=1)\mapsto$ ![](../img/applesc.png)
