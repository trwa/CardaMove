---
marp: false
theme: gaia
---

# Stateful Smart Contracts On Cardano

## Part 1. Minting Unique Tokens With A Shared `PolicyId`

Lorenzo Fanton

887857@stud.unive.it

---

## Problem

Our goals:

1. We want to distribute a smart contract's state over mutiple UTxOs, _and_...

2. ... We need to ensure that it cannot be compromised by an attacker.

Otherwise, it would be pointless to use whatever abstractions we might come up with.

---

## Problem

An informal statement of the problem might be the following.

> A smart contract's state, distributed over a set of UTxOs, should be modified only by transactions validated by the smart contract itself.

---

## Problem

There are good news and bad news.

* **Good news**: Smart contracts (on-chain) can enforce the recipient(s) of the UTxOs being created, but...

* **Bad news**: ... They have **zero knowledge** about the sender of the UTxOs being spent.

Why is that a problem?

---

## Example: Good State

![height:400px](./img/auth-good-state.png)

---

## Example: Attacker

![height:400px](./img/auth-attacker.png)

---

## Example: (Very) Bad State

![height:400px](./img/auth-bad-state.png)

---

## Problem

Compromised state could be the source of other, more serious issues. 

What could be worse than WW3? Well, for example:

> _You_ could be losing money!!

While total thermonuclear annihilation might be somewhat tolerable and even fun, losing money is not and we must avoid that at all costs.

---

## Native Tokens

Native tokens, also called _assets_, are defined as:

* $\text{AssetId} := \text{PolicyId} \times \text{AssetName}$
* $\text{PolicyId} := (\mathbb{F}_{256})^{28}$ (hash of the minting validator script)
* $\text{AssetName} := (\mathbb{F}_{256})^{32}$ (arbitrary string)

Where $\mathbb{F}_q := \lbrace 0,\dots,q-1 \rbrace$.

---

## Spending Validators

We call $V$ the type of a Spending Validator:

$$
V := (\text{Datum} \times \text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

---

## Minting Validators

We call $M$ the type of a Minting Validator:

$$
M := (\text{Redeemer} \times \text{ScriptContext}) \rightarrow \mathbb{B}
$$

**NB**: Minting Validators do not take a $\text{Datum}$ as inputs, because they do not consume UTxOs.

---

## Authorizing NFT

Let $\text{OutputReference}$ represent an on-chain reference to an UTxO.

We declare the following functions:

$newm : (\text{OutputReference}) \rightarrow M$

$addv : (M \times M) \rightarrow V$

$addm : (M \times \text{AssetName}) \rightarrow M$

---

## Authorizing NFT: $newm$

$newm$ takes an $\text{OutputReference}$ `utxo` and returns a Minting Validator that produces a single token with $\text{AssetName}$ `"Auth"`. The script is a one-time minting validator, because it ensures that `utxo` is consumed in the transaction (which can happen only once).

---

## Code: $newm$

![height:400px](./img/auth-newm-code.png)

---

## Code: $addv$

![height:400px](./img/auth-addv-code.png)

---

## Code: $addm$

![height:400px](./img/auth-addm-code.png)

---

## Examples

$DS($![](./img/eiffel.png) $,\sigma=100, \epsilon=0.0001, \theta=0.3, k=2)\mapsto$ ![](../img/eiffelc.png)

$DS($![](./img/baseball.png) $,\sigma=100, \epsilon=0.001, \theta=0.4, k=3)\mapsto$ ![](../img/baseballc.png)

$DS($![](./img/rat.png) $,\sigma=100, \epsilon=0.001, \theta=0.1, k=3)\mapsto$ ![](../img/ratc.png)

$DS($![](./img/apples.jpg) $,\sigma=100, \epsilon=0.001, \theta=0.08, k=1)\mapsto$ ![](../img/applesc.png)
