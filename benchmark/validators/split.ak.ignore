use aiken/collection/dict
use aiken/collection/list
use aiken/collection/pairs
use cardano/assets.{AssetName, PolicyId, tokens}
use cardano/transaction.{
  Datum, InlineDatum, Input, Output, OutputReference, Transaction, find_input,
  find_script_outputs,
}

pub type Storage {
  value: Int,
}

pub type Empty {
  Empty
}

validator token(_id: ByteArray) {
  mint(_r: Empty, _p: PolicyId, _s: Transaction) {
    True
  }

  else(_) {
    fail
  }
}

validator baseline(_id: ByteArray) {
  spend(_d: Option<Storage>, _r: Empty, _u: OutputReference, _s: Transaction) {
    True
  }

  else(_) {
    fail
  }
}

fn find_inputs(self: Transaction, utxo: OutputReference) -> List<Output> {
  expect Some(input) = find_input(self.inputs, utxo)
  expect Some(address) = input.output.reference_script
  find_script_outputs(
    self.inputs
      |> list.map(fn(input: Input) { input.output }),
    address,
  )
}

fn find_outputs(self: Transaction, utxo: OutputReference) -> List<Output> {
  expect Some(input) = find_input(self.inputs, utxo)
  expect Some(address) = input.output.reference_script
  find_script_outputs(self.outputs, address)
}

fn is_me(utxo: OutputReference) {
  utxo.output_index == 0
}

fn tokens_and_datums(
  inputs: List<Output>,
  mint: ByteArray,
) -> List<(AssetName, Storage)> {
  let kvs =
    inputs
      |> list.filter_map(
          fn(output: Output) {
            let toks = tokens(output.value, mint) |> dict.to_pairs
            when toks is {
              [asset] -> {
                expect name: Data = asset.1st
                expect storage: Data = output.datum
                Some((name, storage))
              }
              _ -> None
            }
          },
        )
  let kvs =
    kvs
      |> list.map(
          fn(kv: (Data, Data)) {
            expect name: AssetName = kv.1st
            expect storage: Storage = kv.2nd
            (name, storage)
          },
        )
  kvs
}

validator access_one(mint: ByteArray) {
  spend(
    _datum: Option<Storage>,
    _redeemer: Empty,
    utxo: OutputReference,
    self: Transaction,
  ) {
    expect inputs = find_inputs(self, utxo)
    expect outputs = find_outputs(self, utxo)
    expect kvin = tokens_and_datums(inputs, mint)
    expect kvout = tokens_and_datums(outputs, mint)
    expect Some(kv0in) = list.at(kvin, 0)
    expect Some(kv0out) = list.at(kvout, 0)
    //expect kv0in == kv0out
    True
  }

  else(_) {
    fail
  }
}


// Get the inputs that have the token
    let tokens_datums: Pairs<AssetName, Storage> =
      self.inputs 
        |> list.map(fn(input) { input.output })
        |> list.filter(
            fn(output) { policies(output.value) |> list.has(policy_id) },
          )
        |> list.map(
            fn(output) {
              expect [pair]: Pairs<AssetName, Int> =
                tokens(output.value, policy_id) |> dict.to_pairs

              expect InlineDatum(datum) = output.datum
              expect storage: Storage = datum
              Pair(pair.1st, storage)
            },
          )
        |> list.map(
            fn(pair) {
              let name: AssetName = pair.1st
              compare(name, )
              Pair(name, storage)
            },
          )
        )

    // Check that my asset is the smallest
    |> list.all